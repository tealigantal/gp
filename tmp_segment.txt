            try:
                res = pick_once(self.repo, self.session, date=d2 or None, topk=k2, template=tpl2, mode=md2,
                                positions=self.state.positions if getattr(self.state,'no_holdings',False) else None,
                                cash=getattr(self.state,'cash_available',None), exclusions=getattr(self.state,'exclusions',None),
                                no_holdings=getattr(self.state,'no_holdings',False))
                # Update state
                self.state.default_date = res.date
                self.state.last_pick = {'date': res.date, 'mode': res.mode, 'provider': res.provider, 'ranked_list': res.ranked}
                # Build JSON
                recs = []
                for r in res.ranked:
                    why = r.get('reasons')
                    if isinstance(why, str):
                        why_list = [why] if why else []
                    else:
                        why_list = list(why or [])
                    recs.append({
                        'rank': int(r.get('rank', 0) or 0),
                        'code': str(r.get('ts_code','')),
                        'name': None,
                        'action': 'BUY',
                        'score': float(r.get('score', 0.0) or 0.0),
                        'confidence': float(r.get('confidence', 0.0) or 0.0),
                        'suggested_order': {'shares': int(r.get('suggest_qty', 0) or 0), 'est_price': None},
                        'why': why_list,
                        'risk_flags': [],
                    })
                status = res.data_status
                # daily missing -> risk flag
                daily_missing_codes = list(status.get('daily_missing', []) or [])
                if daily_missing_codes:
                    for x in recs:
                        # just annotate overall
                        x['risk_flags'].append('DATA_GAP')
                min5_pairs = 0
                mm = status.get('min5_missing', {}) or {}
                if isinstance(mm, dict):
                    min5_pairs = sum(len(v) for v in mm.values())
                    if min5_pairs:
                        for x in recs:
                            x['risk_flags'].append('MIN5_MISSING')

                # Compose new pipeline (market info + judge + QA)
                # Build user profile from session state
                profile = {
                    'risk_level': getattr(self.state, 'risk_pref', None) or 'neutral',
                    'style_preference': None,
                    'universe': 'Aè‚?,
                    'max_positions': int(getattr(self.state, 'default_topk', 3) or 3),
                    'sector_preference': [],
                    'max_drawdown_tolerance': None,
                    'topk': int(res.topk or 3),
                }
                try:
                    pipe = CorePipeline(self.repo, llm_cfg='configs/llm.yaml', search_cfg='configs/search.yaml', strategies_cfg=str(self.repo / 'configs' / 'strategies.yaml'), cfg=CorePipelineConfig(lookback_days=14, topk=res.topk, queries=["Aè‚?å¸‚åœº ä¸¤å‘¨ æ‘˜è¦", "æŒ‡æ•° æˆäº¤é¢?æƒ…ç»ª", "æ¿å— è½®åŠ¨ çƒ­ç‚¹"]))
                    run_id, mc, sel, runs, champ, final = pipe.run(end_date=res.date, user_profile=profile, user_question=str(raw), topk=res.topk)
                    self.state.last_run_id = run_id
                    # Extend text with market summary and champion
                    extra_lines = []
                    ms = (mc.market_style_guess or {}).get('reason') if hasattr(mc, 'market_style_guess') else None
                    if not ms and isinstance(mc, dict):
                        ms = (mc.get('market_style_guess') or {}).get('reason')
                    if ms:
                        extra_lines.append(f"è¿‘ä¸¤å‘¨å¸‚åœºæ‘˜è¦ï¼š{str(ms)[:160]}")
                    extra_lines.append(f"å† å†›ç­–ç•¥ï¼š{champ.get('name')}ï¼ˆ{champ.get('reason')}ï¼?)
                    if final and getattr(final, 'risks', None):
                        # final is RecommendationResponse
                        risks = final.risks if isinstance(final.risks, list) else []
                        if risks:
                            extra_lines.append('é£é™©æç¤ºï¼? + 'ï¼?.join(risks[:3]))
                    text = ("\n".join(extra_lines) + "\n\n" + self._build_pick_text(res)) if extra_lines else self._build_pick_text(res)
                except Exception:
                    text = self._build_pick_text(res)
                debug = None
                if include_debug:
                    debug = {'tool_trace_digest': res.trace}
                return {
                    'schema_version': 'gp.assistant.v1',
                    'type': 'pick',
                    'ok': True,
                    'request': {
                        'raw_user_text': raw,
                        'intent': 'pick',
                        'requested_date': res.requested_date,
                        'topk': res.topk,
                        'template': res.template,
                        'mode': res.mode,
                    },
                    'decision': {
                        'effective_date': res.date,
                        'fallback_reason': res.fallback_reason,
                        'provider': res.provider,
                        'provider_reason': ('LLM æ’åºæˆåŠŸï¼ˆå€™é€‰æ± å·²æ ¡éªŒï¼‰' if res.provider == 'llm' else 'LLM ä¸å¯ç”?å¤±è´¥ï¼Œå·²ä½¿ç”¨ mock è¿›è¡Œè¡¥é½ä¸æ’åº?),
                    },
                    'data_status': {
                        'pool_path': str((self.repo / 'universe' / f"candidate_pool_{res.date}.csv")),
                        'pool_count': int(status.get('pool_count', 0) or 0),
                        'daily_missing_codes': daily_missing_codes,
                        'min5_missing_pairs_count': int(min5_pairs),
                        'meta_missing_days': [],
                        'doctor_status': None,
                    },
                    'portfolio_context': {
                        'cash_available': getattr(self.state, 'cash_available', None),
                        'positions': [{'code': k, 'shares': v} for k, v in getattr(self.state, 'positions', {}).items()],
                        'exclusions': list(getattr(self.state, 'exclusions', [])),
                    },
                    'recommendations': recs,
                    'text': text,
                    'next_steps': [],
                    'debug': debug,
                }
            except Exception as e:
                # Return an error JSON, never crash
                return {
                    'schema_version': 'gp.assistant.v1',
                    'type': 'error',
                    'ok': False,
                    'request': {
                        'raw_user_text': raw,
                        'intent': 'pick',
                        'requested_date': req_date,
                        'topk': getattr(self.state, 'default_topk', 5),
                        'template': getattr(self.state, 'default_template', 'momentum_v1'),
                        'mode': getattr(self.state, 'default_mode', 'auto'),
                    },
                    'decision': {'effective_date': None, 'fallback_reason': str(e), 'provider': None, 'provider_reason': 'pick failed: exception'},
                    'data_status': {},
                    'portfolio_context': {
                        'cash_available': getattr(self.state, 'cash_available', None),
                        'positions': [{'code': k, 'shares': v} for k, v in getattr(self.state, 'positions', {}).items()],
                        'exclusions': list(getattr(self.state, 'exclusions', [])),
                    },
                    'recommendations': [],
                    'text': f'å‘ç”Ÿé”™è¯¯ï¼š{e}ã€‚å»ºè®®å…ˆä¿®å¤æ•°æ®æˆ–é…ç½®åå†è¯•ã€?,
